# Sprint S29 — AI 任務非同步處理，提升使用者體驗

> **狀態**: `completed`
> **預估時間**: 3.5 小時
> **前置 Sprint**: S28

---

## Stage 0: Sprint Kickoff

### Sprint 目標宣告

> 重構「AI 智慧記錄」功能，將其從「同步等待」模式升級為「非同步背景處理」模式，徹底解決在呼叫外部 API 時，前端介面會被凍結的問題，提升系統的可靠性與使用者體驗。

---

## Stage 1: Sprint Planning

### User Stories

- [x] **US-1**: 作為使用者，當我提交一段文字給「AI 智慧記錄」後，我希望能立即得到「任務已提交」的回應，並且可以繼續操作其他功能，而不需要在原地等待 AI 處理完成。
- [x] **US-2**: 當背景的 AI 任務處理完成後，我希望能以某種形式（例如頁面上的提示）得知結果。

### Definition of Done（完成定義）

- [x] **DoD-1**: `database/schema.sql` 中已新增 `ai_task_queue` 資料表，用於存放待處理的 AI 任務。
- [x] **DoD-2**: `pages/work_log.py` 的提交邏輯已修改：現在點擊提交只會將任務寫入 `ai_task_queue` 表，並立即在 UI 上顯示成功提交的訊息。
- [x] **DoD-3**: 專案中已建立一個新的 `worker.py` 獨立腳本。
- [x] **DoD-4**: 執行 `python worker.py` 可以成功地從佇列中取出「待辦」任務，呼叫 Gemini API，並將結果寫回對應的 `crm`、`work_log` 等資料表。
- [x] **DoD-5**: `worker.py` 在處理完任務後，會將 `ai_task_queue` 中對應的任務狀態更新為「已完成」或「失敗」。

### Context Files（AI 參考檔案）

- `services/intelligent_log.py`
- `pages/work_log.py`
- `database/schema.sql`

---

## Stage 2: Vibe Coding

### 實作紀錄

1.  **資料庫層 (DB)**:
    - 在 `database/schema.sql` 中，新增了 `ai_task_queue` 資料表的 `CREATE TABLE` 語句。表格包含 `status`, `raw_text`, `result_data`, `error_message` 等欄位。
2.  **服務層 (Service)**:
    - 建立新檔案 `services/task_queue.py`。
    - 實作 `create_task(raw_text)`，將新任務以 `pending` 狀態插入佇列。
    - 實作 `get_next_pending()`，使用 `FOR UPDATE SKIP LOCKED` 的 SQL 語法，以原子操作的方式安全地取出一個待辦任務，並將其狀態更新為 `processing`，避免多個 worker 重複處理。
    - 實作 `update_task_status(...)`，用於在任務處理完成後，將其狀態更新為 `completed` 或 `failed`。
    - 實作 `get_recent_tasks()`，讓 UI 可以查詢最近的任務狀態。
3.  **介面層 (UI)**:
    - 大幅重構 `pages/work_log.py`。
    - 在「AI 智慧記錄」分頁中，將表單提交的邏輯，從直接呼叫 AI 服務，改為僅呼叫 `task_queue_svc.create_task()`。
    - 提交後，UI 立即顯示成功訊息，不再等待。
    - 新增一個「AI 任務佇列」分頁，呼叫 `task_queue_svc.get_recent_tasks()` 並將任務列表以 `st.dataframe` 形式呈現，讓使用者可以追蹤處理進度。
4.  **背景工人 (Worker)**:
    - 在專案根目錄建立新檔案 `worker.py`。
    - 該腳本包含一個無限迴圈 `while True:`。
    - 迴圈中，它會呼叫 `task_queue_svc.get_next_pending()` 來領取任務。
    - 領取到任務後，在一個 `try...except` 區塊中，依序執行完整的處理流程：`il_svc.parse_log_entry` -> `crm_svc.find_or_create_client` -> `work_log_svc.create` -> `project_svc.find_or_create_project`。
    - 根據執行結果，呼叫 `task_queue_svc.update_task_status()` 將任務標記為 `completed` 或 `failed`。
    - 每次迴圈結束後，`time.sleep(10)`，避免過度頻繁地查詢資料庫。

### TODO / 技術債

- 無。

---

## Stage 3: Sprint Review

### DoD 驗證結果

| # | 條件 | 通過? | 備註 |
|---|---|---|---|
| 1 | `ai_task_queue` 表已建立 | ✅ | |
| 2 | UI 提交邏輯已更新 | ✅ | |
| 3 | `worker.py` 已建立 | ✅ | |
| 4 | Worker 可成功處理任務 | ✅ | |
| 5 | Worker 可更新任務狀態 | ✅ | |

---

## Stage 4: Retrospective & Refactor

### 修復項目

- 無。

### Retro: What went well

- 這是一次成功的、有重大意義的架構升級。非同步處理模式讓 AI 功能的體驗和可靠性都提升了一個檔次。
- 「佇列-工人」的設計模式非常清晰，職責分離明確，為未來擴展其他類型的背景任務（如發送郵件、產生報表）打下了良好的基礎。

### Retro: What didn't go well

- 這是一個相對龐大的 Sprint，將其拆分為更小的子任務（例如，一個 Sprint 只建立 DB 和 Service，下一個再做 UI 和 Worker）或許也是一種可行的策略。

### Retro: Action items for next sprint

- [ ] 我們最初規劃的四個架構優化 Sprint 已全部完成。現在，我們可以回到產品功能的迭代上。下一個合乎邏輯的目標是完成 AI 功能的最後一塊拼圖：從文字中解析**日期**與**待辦事項**，並自動在 `project_task` 中建立任務。這將是 Sprint 30 的目標。

### Git Commit

- commit hash: `(待開發者填入)`
- message: `(待開發者填入)`
