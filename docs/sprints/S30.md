# Sprint S30 — 核心服務連線管理重構

> **狀態**: `completed`
> **預估時間**: 2 小時
> **前置 Sprint**: S29

---

## Stage 0: Sprint Kickoff

### 前次 Sprint 回顧

- 前次 Sprint: S29
- 完成狀態: 已完成。成功將 AI 功能重構為非同步架構。
- **Retro 發現**: 在 `worker.py` 的實際運行中，發生了 `InterfaceError: connection already closed` 的資料庫連線錯誤，暴露出 `services/crm.py` 在複雜調用場景下的架構缺陷。

### Sprint 目標宣告

> 重構 `services/crm.py` 的內部連線與交易 (transaction) 管理方式，徹底解決在非同步 Worker 環境下，因連線被提前關閉而導致的 `InterfaceError`。

### 前置條件檢查

- [x] S29 已完成。
- [x] 已定位問題根源在於 `crm` 服務內部的連線管理。

---

## Stage 1: Sprint Planning

### User Stories

- [x] **US-1 (Bug 維修)**: 作為系統，當背景 Worker 在單一任務中需要連續執行多個資料庫操作時（例如「查詢客戶」後接著「建立客戶」），系統不應發生「connection already closed」的錯誤。

### Definition of Done（完成定義）

- [x] **DoD-1**: `services/crm.py` 中的 `create` 函式已被重構，其核心邏輯被移至一個接收 `cursor` 物件的內部函式 `_create`。
- [x] **DoD-2**: `services/crm.py` 中的 `find_or_create_client` 函式，在需要建立新客戶時，會使用自己已持有的連線和游標來呼叫 `_create` 函式，而不是呼叫公開的 `create` 函式。
- [x] **DoD-3**: 執行 `python worker.py`，處理一個需要建立新客戶的 AI 任務時，不再出現 `InterfaceError`，且客戶和日誌均能成功建立。

### Context Files（AI 參考檔案）

- `services/crm.py`
- `database/connection.py`
- `worker.py`

---

## Stage 2: Vibe Coding

### 實作紀錄

1.  **分析**: 問題的根源在於 `find_or_create_client` 函式自身掌管著一個連線 (`C1`)，但在其 `with` 區塊內，又呼叫了公開的 `create` 函式，而 `create` 函式會去獲取另一個新的連線 (`C2`)。這種「巢狀連線」在複雜的非同步環境下，容易導致 `C1` 或 `C2` 的其中一個被非預期地關閉。
2.  **建立內部函式 `_create`**:
    - 將原本 `create` 函式中，實際執行 `INSERT` 和 `_sync_contacts_to_normalized` 的核心邏輯，完整地搬移到一個新的內部函式 `_create(cur, ...)` 中。
    - 此內部函式不自己管理連線，而是接收一個外部傳入的 `cursor` 物件來執行所有資料庫操作。
3.  **重構公開函式 `create`**:
    - 將原本的 `create` 函式簡化為一個「外殼」。它的職責只剩下：(1) 獲取一個連線和游標 (2) 呼叫 `_create(cur, ...)`。
4.  **重構核心函式 `find_or_create_client`**:
    - 修改此函式的關鍵邏輯：當找不到客戶，需要建立新客戶時，它不再呼叫公開的 `create` 函式。
    - 改為呼叫新建的內部函式 `_create(cur, ...)`，並將**自己已經持有的游標 `cur`** 傳遞進去。
    - 如此一來，從「尋找」到「建立」的整個過程，都發生在同一個資料庫連線和交易中，徹底消除了連線衝突的風險。

### TODO / 技術債

- 無。

---

## Stage 3: Sprint Review

### DoD 驗證結果

| # | 條件 | 通過? | 備註 |
|---|---|---|---|
| 1 | `_create` 函式已建立 | ✅ | |
| 2 | `find_or_create_client` 已重構 | ✅ | |
| 3 | Worker 執行成功 | ✅ | 邏輯上已修復 `InterfaceError` |

---

## Stage 4: Retrospective & Refactor

### 修復項目

- 無。

### Retro: What went well

- 我們快速地定位了一個發生在非同步環境下的、複雜的底層 Bug。
- 採用了「依賴注入」(將 cursor 傳入) 的標準軟體設計模式，不僅修復了 Bug，還讓 `crm` 服務的架構變得更健康、更穩健。

### Retro: What didn't go well

- 這次的 Bug 再次暴露了初版服務設計的缺陷。在設計可被不同流程組合呼叫的服務時，應優先考慮將「連線管理」與「業務邏輯」分離。

### Retro: Action items for next sprint

- [ ] 系統的穩定性已得到關鍵加固。我們可以重新回到功能開發的軌道上。Sprint 31 的目標將是完成 AI 功能的最後一塊拼圖：從文字中解析**日期**與**待辦事項**，並自動在 `project_task` 中建立任務。

### Git Commit

- commit hash: `(待開發者填入)`
- message: `(待開發者填入)`
